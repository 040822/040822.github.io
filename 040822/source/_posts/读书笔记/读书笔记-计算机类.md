---
title: 读书笔记-计算机类
date: 2024-06-05 22:43:30
tags:
---
实在不想每读一本书单开一份md文件写几个字然后咕咕了，干脆就把我们所读过的书都统一记在一份markdown上吧。

## 计算机科学导论
快速过一遍这本书
字面意义上的“导论”，快速的过了一遍计科的基础知识，基本就是点到为止。适合计科新生的第一门课和非计科的同学。
如果不想看书的话也可以看下边这个，一共四十集，每集十分钟左右。个人感觉下边这个视频的大纲更好一些，严格讲究从硬件到软件的“自下而上”的抽象过程，内容也更加通俗易懂一些。
[【计算机科学速成课】[40集全/精校] - Crash Course Computer Science_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1EW411u7th/)

### 评价
真正意义上的导论，广而不深，适合像刷知乎一样快速浏览一遍。
虽然是大名鼎鼎的一本书，但是个人感觉不如上边那个速成课。各章之间的关联比较小，可以跳着看或者选择自己感兴趣的主题看，没必要都过一遍。


### 第一章 绪论
基础知识部分，过一遍即可。
#### 1.1 图灵模型
输入数据-》计算机（内有程序）=》输出数据
输入和程序一样，输出就一样。
ok这就是图灵机。
#### 1.2 冯·诺伊曼模型
四个子系统：算术逻辑单元ALU+存储器+控制单元（控制其他三个系统的单元）+I/O设备
程序存储在内存里，程序是一组指令，指令顺序执行。
#### 1.3 计算机组成
计算机=硬件+软件+数据

### 1.4 历史
略
### 1.5以后
略

### 第二章 数字系统
或者说数码系统，讲解各种进制。属于基础知识，需要重点掌握，但不难。
#### 2.2 位置化数字系统
2、8、16、10进制，没了
#### 2.3 非位置化数字系统
例如罗马数字，每个符号大小固定，使用特定的规则来表示数字。

### 第三章 数据存储
基础知识部分，需要重点掌握，尤其是3.2部分。
#### 3.1 数据类型
位bit：一个0/1
位模式：一堆bit，比如一个字节byte=8bit。 更长的位模式一般叫字word

#### 3.2 存储数字
整数：
无符号数：直接二进制，左边补0，可用于计数、寻址、index。
有符号：原码、反码、补码（反码+1）。

实数：
浮点数：符号位+指数位（可正可负）+数据位（尾数）。例如科学计数法。

余码系统：把指数位固定为正的，少存储一个符号，偏移量为$2^{m-1}-1$，m为符号位的位数

IEEE标准：
这段书上有错误。
float：32位 1+8+23. 设符号位为S，指数位为$(T)_{10}$ ，尾数为$(M)_{10}$ ，则数（直观上感觉应该是）$(-1)^S *2^{T-127}*M$，偏移127
double 64位 1+11+52，偏移1023
0的时候，符号指数尾数都设为0

实际的IEEE标准会省略最高位的1，比如：
十进制：11.25  二进制1011.01 规范化$1.01101 *2^{3}$
S=0
T=$(3+127)_{10}$=1000 0010
M=0110 1000 0000 0000 0000 000 注意，这里省略了第一个1
则float编码为 0 1000 0010 0110 1000 0000 0000 0000 000

#### 3.3 存储文本
还是编码，ASCLL，Unicode等

#### 3.4~ 存储其他
音频：采样
图片：矢量图标量图
视频：一堆图片

书上没怎么说，这部分有待后续展开讨论。

### 第四章 数据运算
基础知识，重点掌握，尤其是补码四则。
#### 4.1 逻辑运算
1位或者n位，与或非等等。
复位：置零，不管这个位上是什么数都给它变成0
置位：变1，不管这个位上是什么数都给它变成1

#### 4.2 移位运算
逻辑移位：用于不带符号位的数，因为移位会改变符号
逻辑移位就是直接移位，然后补0。 比如1111右移后变成0111.

循环移位：也是直接移位，但是不是一刀砍式的补0/1. 比如1110右移后变成0111.

算数移位：直观上是，左移乘2，右移除以2。
算术左移：丢掉符号位，右边补0. 比如1001 1001变0011 0010，和逻辑左移一样
算数右移：符号位不变，符号位也右移。比如1001 1001变1100 1100，符号位被复制了。

#### 4.3算术运算
他只讨论了整数加减。
一般：直接转换成补码进行加减
符号加绝对值（原码加减）：略

实数加减：需要统一指数。
这里我们定义一个简单的、不规范的浮点数：IEEE标准, 1+4+6，偏移7，舍弃第一个1.
十进制：A=11.5 B=6.25
A=0 1010 0111 00
B=0 1001 1001 00
指数小的移位，与大的对齐：
B=0 1010 0100 10
（显然，这里舍弃了B的最右边一位）
然后相加：
A+B=0 1010 1011 10 ？
问题来了，IEEE标准中舍弃的那个1该怎么办？网上给出的资料是在对齐这步进行处理的：[verilog实现IEEE754单精度/半精度浮点数加减运算_单精度浮点数加法器设计-CSDN博客](https://blog.csdn.net/m0_51266242/article/details/133637110)

重新对齐：
A=0 1010 (1) 0111 00
B=0 1010 (0) 1100 10
A+B=0 1010 (10) 0011 10 =0 1011 0001 11= 1 0001.11=17.75
结果正确，好长一大段。

对“对齐”的一点思考：如果是 1000000+0.00001这样的大数+小数，对齐之后会变成什么样呢？
```c
int main()
{
    float a,b;
    a=1000000;
    b=0.000001;
    printf("%f\n",a+b);//1000000.000000
    return 0;
}
```
a+b居然等于a，神奇吧。这是因为这里b的1在对齐的过程中被舍弃掉了，从而造成了大数吃小数的情况，在加法中大数吃小数的影响可能不大，但在矩阵运算中的影响就会非常大，因此在数值计算方法中，避免大数吃小数现象非常重要。

### 第五章 计算机组成
基础知识，过一遍即可
#### 5.1 CPU
CPU=ALU+控制单元+寄存器

ALU可以进行逻辑、移位和算术运算，详见数电

寄存器是个超高速超小的存储单元，用于存储数据、指令和计数，详见CSAPP。

控制单元没细讲。
#### 5.2 主存储器
又称为内存。这里也详见数电。

存储器结构是个重要话题。存储器金字塔大概如下：
寄存器=》高速缓冲存储器（cache）=》主存/内存=》外存（=》网络存储设备）
从左到右，存储空间越来越大，单位存储空间价格越来越低，速度越来越慢。

#### 5.3 I/O子系统
非存储设备：键盘、鼠标、打印机等等。
存储设备：硬盘、光盘等等。
#### 5.4 子系统互联
CPU与内存：数据总线、地址总线、控制总线
I/O与这俩：使用各种接口/控制器连到总线上。 有独立寻址和映射寻址两种方法。
映射寻址：把I/O的存储器看作内存的存储器，然后用读取内存的方式读取I/O设备的数据。

```ad-todo
受限于“导论”的需求，感觉很多部分都没怎么细讲。有待于我们后续学习的补充。
```
#### 5.5 程序执行

机器周期：CPU如何执行程序呢？一共有三步：取指令、译码和执行，然后循环这个过程。

I/O操作：当程序需要输入和输出数据时，我们就要把数据进行I/O设备和cpu、内存之间的运输，因为I/O设备的运行速度比CPU慢很多，所以说两者之间就需要同步。同步的方法有：
1. 程序控制I/O：当程序需要输入输出时，CPU停止执行命令，然后不停地查询I/O设备的状态，直至数据传完了（数据是在内存和I/O设备之间进行交换的）。显然，对于这种方法，如果I/O设备一直准备好，CPU就一直不执行下边的命令，这就是浪费时间浪费生命。
2. 中断控制I/O：当程序需要输入输出时，CPU告诉I/O设备要传输数据了，然后CPU继续做自己的事，直到I/O设备准备好，发消息给CPU打断（中断控制）CPU手头的事情，然后CPU开始传输数据。 这种方法对于CPU资源的浪费更少，但如果传输数据太多，CPU频繁被打断，那还是会造成一定的浪费的。
3. 直接存储器存取DMA：DMA是个专门用来读写数据的控制元件，包括一个缓存器。CPU告诉DMA要读写哪些数据，然后当DMA准备好后，将数据从内存传到DMA缓存里（或者反过来）传好后CPU干自己的事去，由DMA将缓存中的数据写入磁盘。

[【DMA】认识 DMA 及其工作流程（与传统CPU存取方式的区别）_cpu dma-CSDN博客](https://blog.csdn.net/challenglistic/article/details/132109276)

#### 5.6 不同的体系结构
CISC，复杂指令集计算机，指令集更大。
RISC，精简指令集计算机，指令集更小。

流水线：[[#5.5 程序执行]]
上边讲CPU的工作流程是：取指令、译码和执行，取指令、译码和执行，取指令、译码和执行……如果CPU要执行n个周期的话，就需要3n个单位时间。有没有办法提高一下速度呢？
实际上，CPU是使用不同电路处理这三个步骤的，也就是说，CPU可以同时取指令、译码、和执行，这样就可以进行流水线操作，将时间缩短为n+4.

并行：SISD、SIMD、MISD、MIMD

#### 5.7 简单计算机
一个例子，见书。

### 第六章 计算机网络
讲的比较浅

#### 6.1 引言

#### 6.2 TCP/IP
应用层、传输层、网络层、数据链路层、物理层

#### 6.3 层
应用层：
客户端/服务器端体系、进程到进程、应用层地址（URL=》域名服务器DNS解析=》IP地址）
IP地址用来标识计算机。

传输层：负责客户端进程和服务器端进程之间消息的逻辑传输。
传输层地址：端口号，用于标识进程。
多路复用和解多路复用：
拥塞控制、流量控制、差错控制

传输层协议：没怎么细讲
1. UDP：接收者检查数据包损没损坏，如果损害只丢包别的什么都不做，优点是速度快。（参见UDP笑话：I told an UDP joke but you didn’t get it）
2. TCP：数据包丢失或者顺序错了，就告诉发送者让它重新发送数据包。
3. SCTP：杂交种

网络层：负责发送/接受数据包。
网络层地址
路由选择
网络层协议：IP主协议加上辅助协议。
IP：IPv4、IPv6.

数据链路层：

物理层：

#### 6.4 互联网应用
邮箱、FTP、远程登录TELNET、Web（http）等。

### 第七章 操作系统

#### 7.1 引言
操作系统是硬件和用户（程序/人）之间的一个接口。
操作系统也是程序，那它如何运行呢？——自举
#### 7.2 演化
说是演化，但下边这几项之间并不完全是严格的演化关系。
批处理系统：实现程序A执行完了之后去执行程序B
分时系统：给不同程序分配资源，以高效利用计算机资源。
个人系统：比如DOS
并行系统：针对多个CPU的电脑的
分布式系统：针对多台电脑的
实时系统：需要在（较短的）限制时间内完成任务。比如汽车的控制系统，就需要在较短的时间内完成对车辆的控制，不然就车毁人亡了。

#### 7.3 组成部分
用户页面：shell or GUI
设备管理器：管理设备的，参见windows上的那个
文件管理器：管理文件的，也参见windows上的那个

**内存管理器**：
单道程序：内存（除了操作系统以外）只装一个程序的数据，程序执行完之后再装下一个。
多道程序：能同时装n个。

分区调度：把内存分为n个区，每个区装一个程序的数据。如果程序A进入I/O（CPU空闲）或者运行完毕，CPU就去另一个区执行程序B。
注意，每个区的地址是在物理上连续的，这就意味着如果程序区的内存不够用的话，就需要重新找一片连续区域。
问题：内存的分配是个老大难问题，要么就是分配少了，程序用着用着内存不够用了，要么就是分配多了，程序用不了，这个程序区还剩下一大片空间没用。内存管理器虽然可以动态分配内存，但这要占用一部分计算资源。

分页调度：把内存分为大小相同的n部分，叫做“帧”；程序也分为大小相同的n部分，叫做“页”。一般页和帧的大小一样。写入程序时就把程序的各个页同时写入内存的不同帧里，无需保证帧的物理地址连续，由内存管理器做映射，让这不连续的帧的地址“看上去”是连续的。

问题：如果空闲帧比程序的页要少的话，那就没法写入了。

请求分页调度：现在，程序写入时不需要将所有页都写入内存，而是按需写入，只写入几个页。前边的页执行完了之后就可以写入下一个页。

分段操作：程序被分为n个段，程序的段的大小并不是一样的，而是根据程序的功能所划分的。比如程序A分为主函数和两个子函数，那就可以分为三个段。内存的段的大小是一样的（？）

请求分页和分段调度：杂交。

虚拟内存：程序正在运行的一部分放在内存里，没运行或者运行结束的放回硬盘里。

**进程管理器：**


### 第八章 算法
略。
### 第九章 程序设计语言
看9.4之前学个python先

#### 9.1 演化
略
#### 9.2 翻译
高级语言=》（汇编=》）机器语言
编译：翻译整个源程序，比如c
解释：一行一行翻译并执行，比如python

翻译过程：词法分析器=》语法分析器=》语义分析器=》代码生成器。详见编译原理。

#### 9.3 编程模式
过程式、面向对象、函数式（lisp）、说明式（prolog）

#### 9.4 共同概念
略

### 第十章 软件工程

### 第十一章 数据结构
讲数组、记录？、链表。不如看专门的数据结构与算法书。

### 第十二章 抽象数据类型
讲栈、队列、线性表、树、图等等，不如看专门的数据结构与算法书。

### 第十三章 文件结构
散列没细讲。
#### 13.1 存取方法
顺序、随机
#### 13.2 顺序文件
文件末尾用EOF标记。
更新顺序文件：没看明白

#### 13.3 索引文件
将键key映射到地址的文件。比如文件名“114514.jpg”=》地址0x114514

#### 13.4 散列文件
索引文件记录key和地址，散列文件不记录这些，只给出一个函数，输入key输出地址。

散列方法：
1. 直接法，键=地址。比如数组，int a[100]，那么提前分配好100个地址，然后直接把地址* a+idx当作键
2. 求模法：地址 = key % （文件列表大小+1）
3. 其他。

冲突：除了直接法，其他散列方法大多不是一一对应的，因此两个key可能对应同一个地址，这就冲突了。
解决办法：
1. 开放寻址。比如两个键的地址都是214，第一个放在地址214，第二个放在其他地方（比如地址215）
2. 链表法：第一个放在214，214地址存一个指向下一个节点的指针
3. 桶散列法：把214地址改成一个桶。




### 第十四章 数据库

### 第十八章 人工智能
这章建议跳过，哪怕看Wikipedia都比看这章强。内容过老过浅了，完全没有看的价值。
#### 18.1 引言
重点关注智能体agent（不过导论没怎么讲），其他了解即可。
至于专为AI设计的语言lisp和prolog感觉都死了好久了（
#### 18.2 知识表示
这部分比较陈旧，仅作了解即可。

语义网、框架、谓词逻辑、基于规则的系统。

语义网：一个有向图。顶点表示概念，边表示关系。比如：江苏=（省份）=》中国

框架： 用数据结构/面向对象来表示与语义网一样的知识。

谓词逻辑：命题逻辑略=》谓词逻辑，或者说命题函数/泛函。

句子, 形如： 谓语（参数1，参数2,...)
参数可以是对象、变量、函数、常数（T、F）等等，返回值是T/F

量词：全称存在

推演：三段论等等。

#### 18.3 专家系统
大概已经死了？

#### 18.4 感知
可深入了解，虽然知识也很陈旧，但目前主流算法依然以此为基础。

1. 图像处理
	关键在于提取图像特征。部分内容和方法过于陈旧
	1. 边缘探测：可以用于分别对象和背景。简单的方法就是做个差分。
	2. 分段：segmentation，把对象分成不同区域，没讲是干啥的
	3. 查找深度：深度指图像某个对象距离相机多远。讲了两种方法：立体视觉（两台相机照同一个对象，三角测距或其他方法）和运动（拍一系列照片，根据运动物体与其他对象之间的相对位置变换来判断远近）。问题在于这两种方法都似乎只能定性判断，定量的话精确值不高。计算机视觉那边应该会进一步深入讲解这块。
	4. 查找方向：光照纹理识别
	5. 对象识别：
2. 语言理解（nlp？）
	随着llm的崛起，nlp领域的很多方法已经过时了，因此掌握nlp的传统研究问题比掌握方法更重要。
	1. 语音识别：本书略了
	2. 语法分析：文法、词法分析机。这块编译原理那边也有涉及。
	3. 语义分析
	4. 语用分析

#### 18.5 搜索
重点，目前很多所谓的机器学习的方法依然是基于搜索的。
暴力搜索：深度广度优先搜索
启发式搜索：给每个节点一个启发值，然后贪心地搜索启发值之和最小的路径。

#### 18.6 神经网络
略。讲的非常浅，不如看wiki。













## 编码的奥秘
[编码的奥秘 (豆瓣) (douban.com)](https://book.douban.com/subject/1024570/)
“科普”级别但涉及内容非常多的一本书，适用于中学生和非CS、EE专业的学生。
等有时间的时候再过一遍。
虽然名字叫做“编码”的奥秘，但内容不仅限于编码，反而更像是数电科普书。
内容包括组合逻辑电路、时序逻辑电路（触发器及其应用）、RAM、CPU、总线操作系统甚至图形化，内容非常非常多。

### 前几章
前几章内容比较少，放一块。
1. 摩斯码
2. 摩斯码树形图-二元码。摩斯码的树形图有点像哈夫曼树那种，做了优化。
3. 布莱叶盲文
4. 手电筒剖析，居然在讲手电筒的发光原理。
5. 构建灯泡通信电路
6. 电报机与继电器（线圈自感互感那个）
7. 十进制计数法 为啥这个要单开一章
8. 其他进制
9. 二进制数 居然扯到了胶卷的，后边还有对条形码的介绍，以及奇偶校验
10. 逻辑和开关 布尔代数，启动
11. 逻辑门电路 不过是基于灯泡和线圈电路的
12. 二进制加法器 搞出与或非之后的第一件事就是构建加法器（
13. 减法器 引入反码补码
14. 反馈！与触发器  
	首先用电池与线圈还有金属簧片构建了个负反馈蜂鸣器（振荡器），很奇妙，然后引入R-S触发器和D触发器和一堆什么边缘触发什么锁存器什么分频器计数器，讲的不少
15. 字节byte（8bit） 十六进制
16.  存储器结构：使用锁存器等等构建8x1RAM，再从8x1RAM开始构建更大的RAM



## 逆向工程权威指南
英文名：Reverse Engineering for Beginners，相对没有那么“可怕”一点。
翻译居然是一个技术大佬带着一整个技术团队进行的，第一次看到一整个专业技术团队翻的书。
全书很长，但比起长度，章节之多更为瞩目，仅480页的上册就有46个章节，在记笔记的时候我们会对章节进行一个整合。

### 第一部分 Beginning

#### 1 CPU简介/指令集架构
本书涉及的指令集有：
1. x86，Intel开发的（AMD有重要贡献），目前的个人电脑不管cpu是intel还是AMD的都是这个架构
2. ARM：RISC CPU，手机和平板的cpu都是arm指令集
3. MIPS：也是RISC，用于嵌入式系统和超算，和我们关系不大

其他重要的指令集还有个RISC-V，开源的。

#### 2 最简函数
```c
int f()

{

    return 123;

}
```
作者把这玩意翻译成三种汇编了,在下边的部分中我们主要关注x86，兼顾其他两种。

执行 gcc -S -masm=intel 1.c 的结果：
```assembly
	.file	"1.c"
	.intel_syntax noprefix
	.text
	.globl	f
	.type	f, @function
f:
.LFB0:
	.cfi_startproc
	endbr64
	push	rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	mov	rbp, rsp
	.cfi_def_cfa_register 6
	mov	eax, 123
	pop	rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	f, .-f
	.ident	"GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	1f - 0f
	.long	4f - 1f
	.long	5
0:
	.string	"GNU"
1:
	.align 8
	.long	0xc0000002
	.long	3f - 2f
2:
	.long	0x3
3:
	.align 8
4:

```
好长一大段
核心就是：
```assembly
	push	rbp
	mov	rbp, rsp
	mov	eax, 123
	pop	rbp
	ret
```
##### 解释
这是一个使用 Intel 语法的 x86-64 汇编程序，它定义了一个名为 `f` 的函数，该函数返回整数 `123`。以下是对这个程序的逐行解释：

- `.file "1.c"`：这是源文件名，通常由编译器自动插入。

- `.intel_syntax noprefix`：这指示汇编器使用 Intel 语法，而不是默认的 AT&T 语法。

- `.text`：这指示汇编器接下来的代码是程序的文本部分，也就是包含实际指令的部分。

- `.globl f`：这使得 `f` 符号在其他文件中可见，也就是说 `f` 是一个全局函数。

- `f:`：这是 `f` 函数的标签，函数的代码从这里开始。

- `.cfi_startproc`：这是调用帧信息的开始，用于异常处理和调试。

- `endbr64`：这是一个 Intel CET（Control-flow Enforcement Technology）的指令，用于防止不合法的间接跳转。

- `push rbp`：这将基指针寄存器（rbp）的值压入堆栈。

- `mov rbp, rsp`：这将栈指针寄存器（rsp）的值复制到基指针寄存器（rbp），用于建立新的堆栈帧。

- `mov eax, 123`：这将整数 `123` 复制到累加器寄存器（eax）。在 x86-64 架构中，函数的返回值是通过 eax 寄存器返回的。

- `pop rbp`：这从堆栈中弹出一个值到基指针寄存器（rbp），恢复之前的堆栈帧。

- `ret`：这是返回指令，它从堆栈中弹出一个地址并跳转到那个地址，从而返回到调用函数。

- `.cfi_endproc`：这是调用帧信息的结束。

- `.size f, .-f`：这定义了 `f` 函数的大小。

- `.ident "GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0"`：这是编译器版本信息。

- `.section .note.GNU-stack,"",@progbits` 和 `.section .note.gnu.property,"a"`：这些是一些特殊的节，用于存储一些元信息。

- 其他的 `.align`、`.long` 和 `.string` 指令用于对齐和定义一些数据和字符串。

#### 3 hello world！



## Git -- cs自学指南
[Git - CS自学指南 (csdiy.wiki)](https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Git/)

[版本控制（Git）·缺失学期 --- Version Control (Git) · Missing Semester (mit.edu)](https://missing.csail.mit.edu/2020/version-control/)
讲解git的原理：文件blobs，目录tree，快照（有向无环图DAG，新提交指向旧提交），内容寻址使用SHA-1，SHA-1的标记References便于人类阅读（比如master）

然后列出一大堆基础命令，带文字说明

[Git 流工作流 | Atlassian Git Tutorial](https://www.atlassian.com/zh/git/tutorials/comparing-workflows/gitflow-workflow)
Gitflow 的总体流程是：
1. `develop` 分支是从 `main` 中创建的
2. `release` 分支是从 `develop` 创建的
3. `feature` 分支是从 `develop` 创建的
4. `feature` 完成后，它会合并到 `develop` 分支中
5. `release` 分支完成后，它将合并到 `develop` 和 `main` 中
6. 如果在 `main` 中检测到问题，则会从 `main` 创建 `hotfix` 分支
7. `hotfix` 完成后，它将合并到 `develop` 和 `main` 中
main：正式发行版本，比如v1.1、v1.2
develop：开发版本，包括所有历史记录
feature：开发某个特性时，从develop单独拉一个分支，开发完合并进去
release：开发差不多之后的测试版本，release分支只修改bug不添加新特性。测试完毕后合到main中用于发行正式版；合到release中用于应用bug修复
hotfix：适用于正式版的bug修复补丁，主要用于正式版出问题时的快速修复，交给专门的快速修复团队进行。

## MIT 6.050J  Information and Entropy
以下为配套note的笔记。
### 序
能量->熵->信息,通过这样的一个类比来引出主题。
These notes present such a unified view of information, in which entropy is one kind of information, but in which there are other kinds as well.

### 1 Bits
bit：度量信息的方式。然后举了个硬币、扑克的例子。

布尔比特-布尔代数-一堆法则
 In Boolean algebra copying is done by assigning a name to the bit and then using that name more than once. Because of this property the Boolean bit is not a good model for quantum-mechanical systems. A different model, the quantum bit, is described below（？）

逻辑电路比特

Control Bit：比如 if a>b，这样的语句

物理比特：若要存储或传输一个比特，它必须具备物理形式。任何用来储存该比特的物体都应具有两种明显不同的状态，其中一个被解释为0，另一个为1。通过将物体置于这两种状态之一来存储比特；当需要该比特时，则测量物体的状态。如果物体在不改变其状态的情况下从一处移动到另一处，则发生了通讯。

量子比特：量子系统三大特性：
1. 可逆性：
	如果某一状态可以通过某种转变过程进入另一状态，那么相反的转变过程也是可行的，因此，量子比特数学中的所有函数都具有可逆性
	然而，在量子系统中至少存在两个重要的不可逆性来源。首先，如果量子系统与环境发生交互，且环境状态未知，则系统中的一部分信息将会丢失。其次，对系统状态进行测量这一行为本身是不可逆的。（？）
2. 叠加态：
	


## 深度强化学习

### 1
概述了强化学习领域。

### 2 REINFORCE 策略梯度算法
算法的思想很简单：寻找一个更好的策略，使得奖励越来越大。使策略变好/奖励变大的方法为：梯度下降法，这使得它与深度学习结合的非常好。
策略：一个神经网络，输入状态输出动作。
回报return：奖励的加权和（衰减奖励）。

如果用深度学习的思路来看的话，就是：
$loss=-E[R(\tau)]$  （注意负号）
然后梯度下降即可。

对梯度的处理：
梯度下降的一个问题在于，return对于神经网络参数不可微，因此没法直接求梯度，需要进行转换；转换完之后用蒙特卡洛的方式求梯度，推导过程见书。
结论：
$$\nabla_{\theta}J(\pi_{\theta})=E_{\tau-\pi}[\Sigma^{t} R(\tau) * \nabla_{\theta} log \pi_{\theta}(a_t|s_t)]$$



## Linux 101
[欢迎 - Linux 101](https://101.ustclug.org/)

### 1 初识Linux

### 2 个性化配置与建站体验
桌面配置+命令行操作+网站建站教程，咱们只看shell

cmatrix程序：模拟黑客帝国 [在 Linux 中玩乐：Cmatrix 之旅 | Linux 中国 - 知乎](https://zhuanlan.zhihu.com/p/669147838)
![[Pasted image 20241022003111.png]]

### 3 软件安装与文件操作
讲一些基础命令。
apt install

cat 查看文件内容，但是cat原本的功能是连接多个文件，然后输出
less 一次只显示一页，且支持向前/后滚动、搜索等功能，语法类似vim
more 一次显示一页，不支持向上滚动，功能较少（实测新版本more增加了回退功能）
most 支持多窗口和高亮显示
[技术|more、less 和 most 的区别](https://linux.cn/article-10253-1.html)

nano 文件编辑器
cp、mv、rm、mkdir

touch 创建文件，但实际上的功能是修改文件的访问时间（access time, atime）和修改时间（modification time, mtime），可以当作是摸（touch）了一下文件，使得它的访问与修改时间发生了变化。当文件不存在时，touch 会创建新文件，所以创建文件也就成为了 touch 最常见的用途。

find
模式匹配：bash 的匹配模式被称为 [glob](https://mywiki.wooledge.org/glob)，语法为*（任意字符串），？（一个任意字符），[a,b] (括号内任意字符串)

tar：将多个文件打包为一个存档文件，本身不进行压缩，可以调用压缩算法来变成压缩包。

man、tldr 查看帮助文档，前者调用软件自带文档，后者调用社区维护的精简版文档（太长不看版本）