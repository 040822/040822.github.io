---
title: 读书笔记-计算机类
date: 2024-06-05 22:43:30
tags:
categories: 读书笔记
---
实在不想每读一本书单开一份md文件写几个字然后咕咕了，干脆就把我们所读过的书都统一记在一份markdown上吧。

## 计算机科学导论
快速过一遍这本书
字面意义上的“导论”，快速的过了一遍计科的基础知识，基本就是点到为止。适合计科新生的第一门课和非计科的同学。
如果不想看书的话也可以看下边这个，一共四十集，每集十分钟左右。个人感觉下边这个视频的大纲更好一些，严格讲究从硬件到软件的“自下而上”的抽象过程，内容也更加通俗易懂一些。
[【计算机科学速成课】[40集全/精校] - Crash Course Computer Science_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1EW411u7th/)

[计算机科学导论（原书第4版） (豆瓣)](https://book.douban.com/subject/35084853/)
### 评价
真正意义上的导论，广而不深，适合像刷知乎一样快速浏览一遍。
虽然是大名鼎鼎的一本书，但是个人感觉不如上边那个速成课。各章之间的关联比较小，可以跳着看或者选择自己感兴趣的主题看，没必要都过一遍。

实际上本书有个坑爹的问题就是，和所有大黑书一样，本书的很多知识点都放在了习题里。但是本书的定位仅仅是入门书，这就导致自学者几乎不会去花时间做那长的要死的书后习题，同时书后习题很多是启发式习题，给一个背景让读者自行研究，做起来效率有点低，所以说这就有点坑爹了。对于非计科的可以花一点时间浏览一遍习题，看看有没有新知识；计科的就没什么必要，直接学后续课程吧。
2025.01.23


### 第一章 绪论
基础知识部分，过一遍即可。
#### 1.1 图灵模型
输入数据-》计算机（内有程序）=》输出数据
输入和程序一样，输出就一样。
ok这就是图灵机。
#### 1.2 冯·诺伊曼模型
四个子系统：算术逻辑单元ALU+存储器+控制单元（控制其他三个系统的单元）+I/O设备
程序存储在内存里，程序是一组指令，指令顺序执行。
#### 1.3 计算机组成
计算机=硬件+软件+数据

### 1.4 历史
略
### 1.5以后
略

### 第二章 数字系统
或者说数码系统，讲解各种进制。属于基础知识，需要重点掌握，但不难。
#### 2.2 位置化数字系统
2、8、16、10进制，没了
#### 2.3 非位置化数字系统
例如罗马数字，每个符号大小固定，使用特定的规则来表示数字。

### 第三章 数据存储
基础知识部分，需要重点掌握，尤其是3.2部分。
#### 3.1 数据类型
位bit：一个0/1
位模式：一堆bit，比如一个字节byte=8bit。 更长的位模式一般叫字word

#### 3.2 存储数字
整数：
无符号数：直接二进制，左边补0，可用于计数、寻址、index。
有符号：原码、反码、补码（反码+1）。

实数：
浮点数：符号位+指数位（可正可负）+数据位（尾数）。例如科学计数法。

余码系统：把指数位固定为正的，少存储一个符号，偏移量为$2^{m-1}-1$，m为符号位的位数

IEEE标准：
这段书上有错误。
float：32位 1+8+23. 设符号位为S，指数位为$(T)_{10}$ ，尾数为$(M)_{10}$ ，则数（直观上感觉应该是）$(-1)^S *2^{T-127}*M$，偏移127
double 64位 1+11+52，偏移1023
0的时候，符号指数尾数都设为0

实际的IEEE标准会省略最高位的1，比如：
十进制：11.25  二进制1011.01 规范化$1.01101 *2^{3}$
S=0
T=$(3+127)_{10}$=1000 0010
M=0110 1000 0000 0000 0000 000 注意，这里省略了第一个1
则float编码为 0 1000 0010 0110 1000 0000 0000 0000 000

#### 3.3 存储文本
还是编码，ASCLL，Unicode等

#### 3.4~ 存储其他
音频：采样
图片：矢量图标量图
视频：一堆图片

书上没怎么说，这部分有待后续展开讨论。

### 第四章 数据运算
基础知识，重点掌握，尤其是补码四则。
#### 4.1 逻辑运算
1位或者n位，与或非等等。
复位：置零，不管这个位上是什么数都给它变成0
置位：变1，不管这个位上是什么数都给它变成1

#### 4.2 移位运算
逻辑移位：用于不带符号位的数，因为移位会改变符号
逻辑移位就是直接移位，然后补0。 比如1111右移后变成0111.

循环移位：也是直接移位，但是不是一刀砍式的补0/1. 比如1110右移后变成0111.

算数移位：直观上是，左移乘2，右移除以2。
算术左移：丢掉符号位，右边补0. 比如1001 1001变0011 0010，和逻辑左移一样
算数右移：符号位不变，符号位也右移。比如1001 1001变1100 1100，符号位被复制了。

#### 4.3算术运算
他只讨论了整数加减。
一般：直接转换成补码进行加减
符号加绝对值（原码加减）：略

实数加减：需要统一指数。
这里我们定义一个简单的、不规范的浮点数：IEEE标准, 1+4+6，偏移7，舍弃第一个1.
十进制：A=11.5 B=6.25
A=0 1010 0111 00
B=0 1001 1001 00
指数小的移位，与大的对齐：
B=0 1010 0100 10
（显然，这里舍弃了B的最右边一位）
然后相加：
A+B=0 1010 1011 10 ？
问题来了，IEEE标准中舍弃的那个1该怎么办？网上给出的资料是在对齐这步进行处理的：[verilog实现IEEE754单精度/半精度浮点数加减运算_单精度浮点数加法器设计-CSDN博客](https://blog.csdn.net/m0_51266242/article/details/133637110)

重新对齐：
A=0 1010 (1) 0111 00
B=0 1010 (0) 1100 10
A+B=0 1010 (10) 0011 10 =0 1011 0001 11= 1 0001.11=17.75
结果正确，好长一大段。

对“对齐”的一点思考：如果是 1000000+0.00001这样的大数+小数，对齐之后会变成什么样呢？
```c
int main()
{
    float a,b;
    a=1000000;
    b=0.000001;
    printf("%f\n",a+b);//1000000.000000
    return 0;
}
```
a+b居然等于a，神奇吧。这是因为这里b的1在对齐的过程中被舍弃掉了，从而造成了大数吃小数的情况，在加法中大数吃小数的影响可能不大，但在矩阵运算中的影响就会非常大，因此在数值计算方法中，避免大数吃小数现象非常重要。

### 第五章 计算机组成
基础知识，过一遍即可
#### 5.1 CPU
CPU=ALU+控制单元+寄存器

ALU可以进行逻辑、移位和算术运算，详见数电

寄存器是个超高速超小的存储单元，用于存储数据、指令和计数，详见CSAPP。

控制单元没细讲。
#### 5.2 主存储器
又称为内存。这里也详见数电。

存储器结构是个重要话题。存储器金字塔大概如下：
寄存器=》高速缓冲存储器（cache）=》主存/内存=》外存（=》网络存储设备）
从左到右，存储空间越来越大，单位存储空间价格越来越低，速度越来越慢。

#### 5.3 I/O子系统
非存储设备：键盘、鼠标、打印机等等。
存储设备：硬盘、光盘等等。
#### 5.4 子系统互联
CPU与内存：数据总线、地址总线、控制总线
I/O与这俩：使用各种接口/控制器连到总线上。 有独立寻址和映射寻址两种方法。
映射寻址：把I/O的存储器看作内存的存储器，然后用读取内存的方式读取I/O设备的数据。

```ad-todo
受限于“导论”的需求，感觉很多部分都没怎么细讲。有待于我们后续学习的补充。
```
#### 5.5 程序执行

机器周期：CPU如何执行程序呢？一共有三步：取指令、译码和执行，然后循环这个过程。

I/O操作：当程序需要输入和输出数据时，我们就要把数据进行I/O设备和cpu、内存之间的运输，因为I/O设备的运行速度比CPU慢很多，所以说两者之间就需要同步。同步的方法有：
1. 程序控制I/O：当程序需要输入输出时，CPU停止执行命令，然后不停地查询I/O设备的状态，直至数据传完了（数据是在内存和I/O设备之间进行交换的）。显然，对于这种方法，如果I/O设备一直准备好，CPU就一直不执行下边的命令，这就是浪费时间浪费生命。
2. 中断控制I/O：当程序需要输入输出时，CPU告诉I/O设备要传输数据了，然后CPU继续做自己的事，直到I/O设备准备好，发消息给CPU打断（中断控制）CPU手头的事情，然后CPU开始传输数据。 这种方法对于CPU资源的浪费更少，但如果传输数据太多，CPU频繁被打断，那还是会造成一定的浪费的。
3. 直接存储器存取DMA：DMA是个专门用来读写数据的控制元件，包括一个缓存器。CPU告诉DMA要读写哪些数据，然后当DMA准备好后，将数据从内存传到DMA缓存里（或者反过来）传好后CPU干自己的事去，由DMA将缓存中的数据写入磁盘。

[【DMA】认识 DMA 及其工作流程（与传统CPU存取方式的区别）_cpu dma-CSDN博客](https://blog.csdn.net/challenglistic/article/details/132109276)

#### 5.6 不同的体系结构
CISC，复杂指令集计算机，指令集更大。
RISC，精简指令集计算机，指令集更小。

流水线：[[#5.5 程序执行]]
上边讲CPU的工作流程是：取指令、译码和执行，取指令、译码和执行，取指令、译码和执行……如果CPU要执行n个周期的话，就需要3n个单位时间。有没有办法提高一下速度呢？
实际上，CPU是使用不同电路处理这三个步骤的，也就是说，CPU可以同时取指令、译码、和执行，这样就可以进行流水线操作，将时间缩短为n+4.

并行：SISD、SIMD、MISD、MIMD

#### 5.7 简单计算机
一个例子，见书。

### 第六章 计算机网络
讲的比较浅

#### 6.1 引言

#### 6.2 TCP/IP
应用层、传输层、网络层、数据链路层、物理层

#### 6.3 层
应用层：
客户端/服务器端体系、进程到进程、应用层地址（URL=》域名服务器DNS解析=》IP地址）
IP地址用来标识计算机。

传输层：负责客户端进程和服务器端进程之间消息的逻辑传输。
传输层地址：端口号，用于标识进程。
多路复用和解多路复用：
拥塞控制、流量控制、差错控制

传输层协议：没怎么细讲
1. UDP：接收者检查数据包损没损坏，如果损害只丢包别的什么都不做，优点是速度快。（参见UDP笑话：I told an UDP joke but you didn’t get it）
2. TCP：数据包丢失或者顺序错了，就告诉发送者让它重新发送数据包。
3. SCTP：杂交种

网络层：负责发送/接受数据包。
网络层地址
路由选择
网络层协议：IP主协议加上辅助协议。
IP：IPv4、IPv6.

数据链路层：

物理层：

#### 6.4 互联网应用
邮箱、FTP、远程登录TELNET、Web（http）等。

### 第七章 操作系统

#### 7.1 引言
操作系统是硬件和用户（程序/人）之间的一个接口。
操作系统也是程序，那它如何运行呢？——自举
#### 7.2 演化
说是演化，但下边这几项之间并不完全是严格的演化关系。
批处理系统：实现程序A执行完了之后去执行程序B
分时系统：给不同程序分配资源，以高效利用计算机资源。
个人系统：比如DOS
并行系统：针对多个CPU的电脑的
分布式系统：针对多台电脑的
实时系统：需要在（较短的）限制时间内完成任务。比如汽车的控制系统，就需要在较短的时间内完成对车辆的控制，不然就车毁人亡了。

#### 7.3 组成部分
用户页面：shell or GUI
设备管理器：管理设备的，参见windows上的那个
文件管理器：管理文件的，也参见windows上的那个

**内存管理器**：
单道程序：内存（除了操作系统以外）只装一个程序的数据，程序执行完之后再装下一个。
多道程序：能同时装n个。

分区调度：把内存分为n个区，每个区装一个程序的数据。如果程序A进入I/O（CPU空闲）或者运行完毕，CPU就去另一个区执行程序B。
注意，每个区的地址是在物理上连续的，这就意味着如果程序区的内存不够用的话，就需要重新找一片连续区域。
问题：内存的分配是个老大难问题，要么就是分配少了，程序用着用着内存不够用了，要么就是分配多了，程序用不了，这个程序区还剩下一大片空间没用。内存管理器虽然可以动态分配内存，但这要占用一部分计算资源。

分页调度：把内存分为大小相同的n部分，叫做“帧”；程序也分为大小相同的n部分，叫做“页”。一般页和帧的大小一样。写入程序时就把程序的各个页同时写入内存的不同帧里，无需保证帧的物理地址连续，由内存管理器做映射，让这不连续的帧的地址“看上去”是连续的。

问题：如果空闲帧比程序的页要少的话，那就没法写入了。

请求分页调度：现在，程序写入时不需要将所有页都写入内存，而是按需写入，只写入几个页。前边的页执行完了之后就可以写入下一个页。

分段操作：程序被分为n个段，程序的段的大小并不是一样的，而是根据程序的功能所划分的。比如程序A分为主函数和两个子函数，那就可以分为三个段。内存的段的大小是一样的（？）

请求分页和分段调度：杂交。

虚拟内存：程序正在运行的一部分放在内存里，没运行或者运行结束的放回硬盘里。

**进程管理器：**


### 第八章 算法
略。
### 第九章 程序设计语言
看9.4之前学个python先

#### 9.1 演化
略
#### 9.2 翻译
高级语言=》（汇编=》）机器语言
编译：翻译整个源程序，比如c
解释：一行一行翻译并执行，比如python

翻译过程：词法分析器=》语法分析器=》语义分析器=》代码生成器。详见编译原理。

#### 9.3 编程模式
过程式、面向对象、函数式（lisp）、说明式（prolog）

#### 9.4 共同概念
略

### 第十章 软件工程

### 第十一章 数据结构
讲数组、记录？、链表。不如看专门的数据结构与算法书。

### 第十二章 抽象数据类型
讲栈、队列、线性表、树、图等等，不如看专门的数据结构与算法书。

### 第十三章 文件结构
散列没细讲。
#### 13.1 存取方法
顺序、随机
#### 13.2 顺序文件
文件末尾用EOF标记。
更新顺序文件：没看明白

#### 13.3 索引文件
将键key映射到地址的文件。比如文件名“114514.jpg”=》地址0x114514

#### 13.4 散列文件
索引文件记录key和地址，散列文件不记录这些，只给出一个函数，输入key输出地址。

散列方法：
1. 直接法，键=地址。比如数组，int a[100]，那么提前分配好100个地址，然后直接把地址* a+idx当作键
2. 求模法：地址 = key % （文件列表大小+1）
3. 其他。

冲突：除了直接法，其他散列方法大多不是一一对应的，因此两个key可能对应同一个地址，这就冲突了。
解决办法：
1. 开放寻址。比如两个键的地址都是214，第一个放在地址214，第二个放在其他地方（比如地址215）
2. 链表法：第一个放在214，214地址存一个指向下一个节点的指针
3. 桶散列法：把214地址改成一个桶。




### 第十四章 数据库

### 第十六章 安全
正好咱们最近在研究密码学，于是就打算快速浏览一遍这一章。
#### 16.1 引言
安全目标：机密性、完整性（避免数据受到未授权的修改）、可用性

安全攻击：
机密性：嗅探（非授权访问数据、侦听数据）、流量分析（分析流量来获取收发地址，猜测信息内容）。
完整性：修改、假冒、回放（把某次合法消息再发送一次，比如打钱交易再来一次，就相当于多打一份钱）、否认（发送者或者接受者否认某次信息，比如淘宝买家否认收到了货要求卖家再发货）
可用性：拒绝服务（DoS攻击）

安全服务：数据机密性，数据完整性，验证（验证发送者接受者、数据源的身份）不可否认（防止发送者接受者的否认），访问控制（防止非授权访问）

技术：密码术Crypto（对称、非对称、散列），隐写术Stego

#### 16.2 对称密钥密码术
收发信息双方共享密钥。
Kerckhoff原则：即使密码系统的任何细节已为人悉知，只要密钥（key）未泄漏，它也应是安全的。换句话说，需要保证密钥的安全。

传统密码：
替换密码：用一个符号替换另一个符号。
比如移位密码/凯撒密码。问题在于可以暴力破解，并且可以从字母的分布进行破解（e的频率高）
置换密码：符号重新排列。
比如abcde=》ecabd

现代密码：
DES：使用56bit密钥来加密64bit明文，解密64bit密文。问题在于1.密钥太短 2.DES内部结构可能有美国国家安全局NSA的后门。

AES：128、192、256bit密钥，搞128bit明文密文。

#### 16.3 非对称密钥密码术
公钥加密，私钥解密。

RSA算法：没细讲。

#### 16.4 对比
#### 16.5 其他安全服务
消息完整性：哈希函数=》数字指纹
消息验证：MAC
数字签名：非对称的公私钥系统，或者哈希
实体验证：使用个人信息证明你是你=》口令验证，质询-响应验证（证明自己知道秘密的存在，并不需要暴露秘密本身），零知识验证，生物测定。

#### 16.6 密钥管理
对称密钥分发：密钥分发中心KDC
公钥分发：认证机构CA


### 第十八章 人工智能
这章建议跳过，哪怕看Wikipedia都比看这章强。内容过老过浅了，完全没有看的价值。
#### 18.1 引言
重点关注智能体agent（不过导论没怎么讲），其他了解即可。
至于专为AI设计的语言lisp和prolog感觉都死了好久了（
#### 18.2 知识表示
这部分比较陈旧，仅作了解即可。

语义网、框架、谓词逻辑、基于规则的系统。

语义网：一个有向图。顶点表示概念，边表示关系。比如：江苏=（省份）=》中国

框架： 用数据结构/面向对象来表示与语义网一样的知识。

谓词逻辑：命题逻辑略=》谓词逻辑，或者说命题函数/泛函。

句子, 形如： 谓语（参数1，参数2,...)
参数可以是对象、变量、函数、常数（T、F）等等，返回值是T/F

量词：全称存在

推演：三段论等等。

#### 18.3 专家系统
大概已经死了？

#### 18.4 感知
可深入了解，虽然知识也很陈旧，但目前主流算法依然以此为基础。

1. 图像处理
	关键在于提取图像特征。部分内容和方法过于陈旧
	1. 边缘探测：可以用于分别对象和背景。简单的方法就是做个差分。
	2. 分段：segmentation，把对象分成不同区域，没讲是干啥的
	3. 查找深度：深度指图像某个对象距离相机多远。讲了两种方法：立体视觉（两台相机照同一个对象，三角测距或其他方法）和运动（拍一系列照片，根据运动物体与其他对象之间的相对位置变换来判断远近）。问题在于这两种方法都似乎只能定性判断，定量的话精确值不高。计算机视觉那边应该会进一步深入讲解这块。
	4. 查找方向：光照纹理识别
	5. 对象识别：
2. 语言理解（nlp？）
	随着llm的崛起，nlp领域的很多方法已经过时了，因此掌握nlp的传统研究问题比掌握方法更重要。
	1. 语音识别：本书略了
	2. 语法分析：文法、词法分析机。这块编译原理那边也有涉及。
	3. 语义分析
	4. 语用分析

#### 18.5 搜索
重点，目前很多所谓的机器学习的方法依然是基于搜索的。
暴力搜索：深度广度优先搜索
启发式搜索：给每个节点一个启发值，然后贪心地搜索启发值之和最小的路径。

#### 18.6 神经网络
略。讲的非常浅，不如看wiki。













## 编码的奥秘
[编码的奥秘 (豆瓣) (douban.com)](https://book.douban.com/subject/1024570/)
“科普”级别但涉及内容非常多的一本书，适用于中学生和非CS、EE专业的学生。
等有时间的时候再过一遍。
虽然名字叫做“编码”的奥秘，但内容不仅限于编码，反而更像是数电科普书。
内容包括组合逻辑电路、时序逻辑电路（触发器及其应用）、RAM、CPU、总线操作系统甚至图形化，内容非常非常多。

### 前几章
前几章内容比较少，放一块。
1. 摩斯码
2. 摩斯码树形图-二元码。摩斯码的树形图有点像哈夫曼树那种，做了优化。
3. 布莱叶盲文
4. 手电筒剖析，居然在讲手电筒的发光原理。
5. 构建灯泡通信电路
6. 电报机与继电器（线圈自感互感那个）
7. 十进制计数法 为啥这个要单开一章
8. 其他进制
9. 二进制数 居然扯到了胶卷的，后边还有对条形码的介绍，以及奇偶校验
10. 逻辑和开关 布尔代数，启动
11. 逻辑门电路 不过是基于灯泡和线圈电路的
12. 二进制加法器 搞出与或非之后的第一件事就是构建加法器（
13. 减法器 引入反码补码
14. 反馈！与触发器  
	首先用电池与线圈还有金属簧片构建了个负反馈蜂鸣器（振荡器），很奇妙，然后引入R-S触发器和D触发器和一堆什么边缘触发什么锁存器什么分频器计数器，讲的不少
15. 字节byte（8bit） 十六进制
16.  存储器结构：使用锁存器等等构建8x1RAM，再从8x1RAM开始构建更大的RAM



## 逆向工程权威指南
英文名：Reverse Engineering for Beginners，相对没有那么“可怕”一点。
翻译居然是一个技术大佬带着一整个技术团队进行的，第一次看到一整个专业技术团队翻的书。
全书很长，但比起长度，章节之多更为瞩目，仅480页的上册就有46个章节，在记笔记的时候我们会对章节进行一个整合。

### 第一部分 Beginning

#### 1 CPU简介/指令集架构
本书涉及的指令集有：
1. x86，Intel开发的（AMD有重要贡献），目前的个人电脑不管cpu是intel还是AMD的都是这个架构
2. ARM：RISC CPU，手机和平板的cpu都是arm指令集
3. MIPS：也是RISC，用于嵌入式系统和超算，和我们关系不大

其他重要的指令集还有个RISC-V，开源的。

#### 2 最简函数
```c
int f()

{

    return 123;

}
```
作者把这玩意翻译成三种汇编了,在下边的部分中我们主要关注x86，兼顾其他两种。

执行 gcc -S -masm=intel 1.c 的结果：
```assembly
	.file	"1.c"
	.intel_syntax noprefix
	.text
	.globl	f
	.type	f, @function
f:
.LFB0:
	.cfi_startproc
	endbr64
	push	rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	mov	rbp, rsp
	.cfi_def_cfa_register 6
	mov	eax, 123
	pop	rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	f, .-f
	.ident	"GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	1f - 0f
	.long	4f - 1f
	.long	5
0:
	.string	"GNU"
1:
	.align 8
	.long	0xc0000002
	.long	3f - 2f
2:
	.long	0x3
3:
	.align 8
4:

```
好长一大段
核心就是：
```assembly
	push	rbp
	mov	rbp, rsp
	mov	eax, 123
	pop	rbp
	ret
```
##### 解释
这是一个使用 Intel 语法的 x86-64 汇编程序，它定义了一个名为 `f` 的函数，该函数返回整数 `123`。以下是对这个程序的逐行解释：

- `.file "1.c"`：这是源文件名，通常由编译器自动插入。

- `.intel_syntax noprefix`：这指示汇编器使用 Intel 语法，而不是默认的 AT&T 语法。

- `.text`：这指示汇编器接下来的代码是程序的文本部分，也就是包含实际指令的部分。

- `.globl f`：这使得 `f` 符号在其他文件中可见，也就是说 `f` 是一个全局函数。

- `f:`：这是 `f` 函数的标签，函数的代码从这里开始。

- `.cfi_startproc`：这是调用帧信息的开始，用于异常处理和调试。

- `endbr64`：这是一个 Intel CET（Control-flow Enforcement Technology）的指令，用于防止不合法的间接跳转。

- `push rbp`：这将基指针寄存器（rbp）的值压入堆栈。

- `mov rbp, rsp`：这将栈指针寄存器（rsp）的值复制到基指针寄存器（rbp），用于建立新的堆栈帧。

- `mov eax, 123`：这将整数 `123` 复制到累加器寄存器（eax）。在 x86-64 架构中，函数的返回值是通过 eax 寄存器返回的。

- `pop rbp`：这从堆栈中弹出一个值到基指针寄存器（rbp），恢复之前的堆栈帧。

- `ret`：这是返回指令，它从堆栈中弹出一个地址并跳转到那个地址，从而返回到调用函数。

- `.cfi_endproc`：这是调用帧信息的结束。

- `.size f, .-f`：这定义了 `f` 函数的大小。

- `.ident "GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0"`：这是编译器版本信息。

- `.section .note.GNU-stack,"",@progbits` 和 `.section .note.gnu.property,"a"`：这些是一些特殊的节，用于存储一些元信息。

- 其他的 `.align`、`.long` 和 `.string` 指令用于对齐和定义一些数据和字符串。

#### 3 hello world！



## Git -- cs自学指南
[Git - CS自学指南 (csdiy.wiki)](https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Git/)

[版本控制（Git）·缺失学期 --- Version Control (Git) · Missing Semester (mit.edu)](https://missing.csail.mit.edu/2020/version-control/)
讲解git的原理：文件blobs，目录tree，快照（有向无环图DAG，新提交指向旧提交），内容寻址使用SHA-1，SHA-1的标记References便于人类阅读（比如master）

然后列出一大堆基础命令，带文字说明

[Git 流工作流 | Atlassian Git Tutorial](https://www.atlassian.com/zh/git/tutorials/comparing-workflows/gitflow-workflow)
Gitflow 的总体流程是：
1. `develop` 分支是从 `main` 中创建的
2. `release` 分支是从 `develop` 创建的
3. `feature` 分支是从 `develop` 创建的
4. `feature` 完成后，它会合并到 `develop` 分支中
5. `release` 分支完成后，它将合并到 `develop` 和 `main` 中
6. 如果在 `main` 中检测到问题，则会从 `main` 创建 `hotfix` 分支
7. `hotfix` 完成后，它将合并到 `develop` 和 `main` 中
main：正式发行版本，比如v1.1、v1.2
develop：开发版本，包括所有历史记录
feature：开发某个特性时，从develop单独拉一个分支，开发完合并进去
release：开发差不多之后的测试版本，release分支只修改bug不添加新特性。测试完毕后合到main中用于发行正式版；合到release中用于应用bug修复
hotfix：适用于正式版的bug修复补丁，主要用于正式版出问题时的快速修复，交给专门的快速修复团队进行。

## MIT 6.050J  Information and Entropy
以下为配套note的笔记。
### 序
能量->熵->信息,通过这样的一个类比来引出主题。
These notes present such a unified view of information, in which entropy is one kind of information, but in which there are other kinds as well.

### 1 Bits
bit：度量信息的方式。然后举了个硬币、扑克的例子。

布尔比特-布尔代数-一堆法则
 In Boolean algebra copying is done by assigning a name to the bit and then using that name more than once. Because of this property the Boolean bit is not a good model for quantum-mechanical systems. A different model, the quantum bit, is described below（？）

逻辑电路比特

Control Bit：比如 if a>b，这样的语句

物理比特：若要存储或传输一个比特，它必须具备物理形式。任何用来储存该比特的物体都应具有两种明显不同的状态，其中一个被解释为0，另一个为1。通过将物体置于这两种状态之一来存储比特；当需要该比特时，则测量物体的状态。如果物体在不改变其状态的情况下从一处移动到另一处，则发生了通讯。

量子比特：量子系统三大特性：
1. 可逆性：
	如果某一状态可以通过某种转变过程进入另一状态，那么相反的转变过程也是可行的，因此，量子比特数学中的所有函数都具有可逆性
	然而，在量子系统中至少存在两个重要的不可逆性来源。首先，如果量子系统与环境发生交互，且环境状态未知，则系统中的一部分信息将会丢失。其次，对系统状态进行测量这一行为本身是不可逆的。（？）
2. 叠加态：
	


## 深度强化学习

### 1
概述了强化学习领域。

### 2 REINFORCE 策略梯度算法
算法的思想很简单：寻找一个更好的策略，使得奖励越来越大。使策略变好/奖励变大的方法为：梯度下降法，这使得它与深度学习结合的非常好。
策略：一个神经网络，输入状态输出动作。
回报return：奖励的加权和（衰减奖励）。

如果用深度学习的思路来看的话，就是：
$loss=-E[R(\tau)]$  （注意负号）
然后梯度下降即可。

对梯度的处理：
梯度下降的一个问题在于，return对于神经网络参数不可微，因此没法直接求梯度，需要进行转换；转换完之后用蒙特卡洛的方式求梯度，推导过程见书。
结论：
$$\nabla_{\theta}J(\pi_{\theta})=E_{\tau-\pi}[\Sigma^{t} R(\tau) * \nabla_{\theta} log \pi_{\theta}(a_t|s_t)]$$



## Linux 101
[欢迎 - Linux 101](https://101.ustclug.org/)

### 1 初识Linux

### 2 个性化配置与建站体验
桌面配置+命令行操作+网站建站教程，咱们只看shell

cmatrix程序：模拟黑客帝国 [在 Linux 中玩乐：Cmatrix 之旅 | Linux 中国 - 知乎](https://zhuanlan.zhihu.com/p/669147838)
![[Pasted image 20241022003111.png]]

### 3 软件安装与文件操作
讲一些基础命令。
apt install

cat 查看文件内容，但是cat原本的功能是连接多个文件，然后输出
less 一次只显示一页，且支持向前/后滚动、搜索等功能，语法类似vim
more 一次显示一页，不支持向上滚动，功能较少（实测新版本more增加了回退功能）
most 支持多窗口和高亮显示
[技术|more、less 和 most 的区别](https://linux.cn/article-10253-1.html)

nano 文件编辑器
cp、mv、rm、mkdir

touch 创建文件，但实际上的功能是修改文件的访问时间（access time, atime）和修改时间（modification time, mtime），可以当作是摸（touch）了一下文件，使得它的访问与修改时间发生了变化。当文件不存在时，touch 会创建新文件，所以创建文件也就成为了 touch 最常见的用途。

find
模式匹配：bash 的匹配模式被称为 [glob](https://mywiki.wooledge.org/glob)，语法为*（任意字符串），？（一个任意字符），[a,b] (括号内任意字符串)

tar：将多个文件打包为一个存档文件，本身不进行压缩，可以调用压缩算法来变成压缩包。

man、tldr 查看帮助文档，前者调用软件自带文档，后者调用社区维护的精简版文档（太长不看版本）


## 深入浅出密码学

### 第一章 引言
基本概念+密码算法分类
协议：参与者通过 逐步交互 实现 机密信息 交换的过程
密码学：考虑在 敌手 存在下使协议变得安全的学科
密码学原语：一类密码算法。 比如对称加密-AES（原语-具体算法）
分类方式：对称加密（一个密钥），非对称加密（多个，密钥交换、非对称加密、数字签名）
密码算法的基本功能：认证性和机密性

### 第二章 哈希函数
#### 2.1
功能：
给一段字符串/一个文件，经过哈希函数生成一段摘要Digest/哈希值Hash。
比如： Hello World！ +》1341f0bfa2bcc13b28b6cadb6aa60665fa1375978c64b881250ca24452547e42
（sha256）
#### 2.2
性质：
抗第一原像性：已知哈希值，无法找到对应的输入。（前提是输入空间要足够大）
抗第二原像性：已知输入和哈希值，无法找到另一个不同的输入，能输出相同的哈希值。
抗碰撞：不能找到两个随机的输入，满足这两个输入的哈希值一样。

随机预言机模型：输出具有确定性、随机性。
[随机预言机 - 维基百科，自由的百科全书](https://zh.wikipedia.org/zh-cn/%E9%9A%A8%E6%A9%9F%E9%A0%90%E8%A8%80%E6%A9%9F)

#### 2.3
哈希值长度的影响=》生日界限/生日悖论（生成空间大小为2^N，已经生成2^N/2个字符串时，发生碰撞的概率是50%）=》安全目标为128bit，即至少执行2^128次操作才能破坏算法=》哈希长度至少为256bit（抗碰撞256bit（生日界限），抗12原像性128bit（固定了一个，所以另一个需要遍历整个空间？））

#### 2.4 应用
2.4.1承诺
2.4.2子资源完整性
2.4.3比特流BitTorrent协议
2.4.4 Tor路由
习题：
显而易见，silkroad6ownowfk.onion 这个字符串并没有 256 比特 （32 字节），那么根据我们在 2.3 节中所学到的知识，这怎么能提供 足够的安全性呢？ 恐惧海盗罗伯茨（丝绸之路网站管理员的昵称）是如何设法获得 一个包含网站名称的哈希值的呢？

claude3.5sonnet
让我们逐步分析这个问题:

1. .onion 地址实际上是用 Base32 编码的 80 位地址(16 个字符)
    
2. 这个地址是通过以下步骤生成的:
    
    - 生成一个 RSA-1024 密钥对
    - 取公钥的 SHA-1 摘要(得到 160 位)
    - 取前 80 位用 Base32 编码
3. 要获得包含特定名称的地址,需要:
    
    - 反复生成密钥对
    - 检查生成的地址是否包含目标字符串
    - 当找到匹配时保存该密钥对

这样就能解释为什么较短的.onion地址仍然安全:
- 底层使用了完整的 RSA-1024 密钥对
- 地址只是公钥哈希的部分表示
- 找到匹配特定字符串的地址需要大量计算

#### 2.5 标准化的哈希函数
MD5、SHA-1已死，SHA-2、3当立。前边这俩抗碰撞性不行。

##### 2.5.1 SHA-2
包括SHA-224、256、384、512（生成hash值的长度）还有512/256（生成512截取256bit）等。
压缩函数：Davies-Meyer 构造方法。
压缩函数的输入和输出长度一样。比如SHA-256，输入输出均为256bit，输入不满足需要做填补。
![[IMG-20250122234538858.png]]
整体结构：Merkle-Damgård 结构。
![[IMG-20250122234705591.png]]
流程：
首先进行填充，然后按照长度将输入分组，然后开始按照上边的流程计算。
其中初始值（上图的Ⅳ）为超参数，SHA256是取质数的平方根的小数部分来做这个初值，具体见wiki。
[SHA-2 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/SHA-2)

PS：如果压缩算法抗碰撞，那么整体结构也抗碰撞。同时由于压缩函数输入输出长度固定，这就降低了分析时的复杂度。
PPS：SHA-2的问题：长度扩展（Length Extension）攻击

##### 2.5.2 SHA-3
NIST举办的安全竞赛的获胜者。
基于keccak-f置换和海绵结构。具体结构略了。感觉目前SHA-2用的比-3多？

##### 2.5.3 SHAKE 和 cSHAKE：两个可扩展输出的函数
XOF 可扩展输出函数（Extendable Output Function）
SHAKE：和SHA-3结构基本一样，改变置换方式。
cSHAKE：需要一个自定义字符串。此自定义字符串可以为空，也可以是任何字符串。这使得我们可以自定义cSHAKE，产生不同的哈希函数，这种特性成为域隔离（Domain Separation）。

##### 2.5.4 元组哈希：避免模糊哈希。
元组哈希（TupleHash），基于cSHAKE提出，允许对一个元组进行哈希。
例如一个元组：（homo，114514，1919）
模糊哈希：
元组=》homo1145141919=》hash。但是在将元组拼接到字符串的时候就产生了模糊性，这个元组和（homo，1145141，919）等价，很容易搞定抗第二原像性。
元组哈希：
先对输入进行序列化（Serialize），比如在每个元素前边加上元素的长度，再hash即可。

#### 2.6 口令哈希
为了防止密码被爆破，需要搞两方面东西：
- 如果攻击者提取到口令的哈希值，则可以进行暴力攻击或穷举搜 索（尝试所有可能的口令）。每次猜测口令时，都针对整个数据库进行 比对。理想情况下，我们希望攻击者一次只能攻击一个口令的哈希值。=》解决方案是加盐，即给每个用户搞一个不同的随机值，随机值+密码之后在hash。这样攻击者一次只能针对一个用户进行爆破，大大提高代价。
- 哈希函数运行速度应该是非常快的。攻击者可以利用它进行暴力 破解（每秒可以产生很多口令）。理想情况下，我们会有一种机制来减 缓此类攻击。=》口令哈希。

最优口令哈希算法：Argon2 算法，是内存困难的，只能通过优化内存访问来优化算法，因此在任何设备上都运行缓慢（包括专用GPU，内存带宽也是有限的）。

![[IMG-20250123001912649.png]]




## 大话存储
[大话存储（终极版） (豆瓣)](https://book.douban.com/subject/26325526/)
个人刚看到第三章磁盘，感觉讲的还可以。不知道豆瓣上为啥评价不高。
书巨厚，多达近1000页。
![[IMG-20250304003711399.png]]
可以关注一下。

抛开豆er认为比较水的武侠部分不谈，本书还是给了我不小的震撼的。本书的覆盖面非常广泛，在细节方面也比较丰富。安排上有点随意有点混乱但是瑕不掩瑜。毕竟我们已经有太多的“专业”的专业书了，生动风趣一点的未尝不好。

### 1 
存储历史：
- 选数管
- 穿孔卡片、纸袋
- 磁带
- 磁鼓存储器
- 硬盘
- 软盘
- 光盘
- Flash闪存=》固态
- 磁盘阵列

信息、数据、数据存储。看看就好，不严谨但是通俗。

### 2 IO
#### 2.1 总线
这个总线的示意图看得我汗颜啊。这个南桥北桥完全没听说过啊。
[计算机组成原理与体系结构 —— 南桥与北桥_微机的南北桥系统结构-CSDN博客](https://blog.csdn.net/qq_38880380/article/details/116325788)
不过目前主板的南桥和北桥已经被取消，这部分的内容可能过时。

PCI总线：
讲的很抽象，只是提一嘴。
PCI总线的中断共享。没看懂。

#### 2.2 计算机内部通信。
网络——连（物理连接）、找（找节点IP）、发。
然后作者提出个想法：把IO总线看成网络，惊为天人。
但这里很多点都是浅尝辄止，只是提一嘴的程度。

### 3
#### 3.1 硬盘结构
盘片
磁头：悬浮在盘片上
步进电机